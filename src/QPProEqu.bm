'-----------------------------------
' FCount Copycat Function
'-----------------------------------
Function FCount% (fileSpec$)

    Const TmpFile$ = "DIR$INF0.INF", ListMAX~& = 8388608

    'The max # of files in a folder of any OS is 4294967295
    'The value used now comes from 1/2'ing this until I got
    'the highest # I could and still get ~1 sec response
    Static Ready%, Index%, DirList$()

    'DIM array for first use
    If Not Ready% Then ReDim DirList$(ListMAX~&): Ready% = -1

    'Get file names when a spec is given
    If fileSpec$ > "" Then

        opSys$ = _OS$
        y% = Len(s$)
        osSpec$ = Left$(_OS$, InStr(2, _OS$, "[") - 1)

        Select Case osSpec$
            Case "[WINDOWS]": Shell _Hide "dir /on /b" + fileSpec$ + " > " + TmpFile$
            Case "[MAC]": Shell _Hide "find . -iname fileSpec$ -type f -print0 | sort -z | tee TmpFile"
            Case "[LINUX]": Shell _Hide "find . -iname fileSpec$ -type f -print0 | sort -z | tee TmpFile$'"
        End Select

        Index% = 0: DirList$(Index%) = "": ff% = FreeFile

        'Determine file size
        Open TmpFile$ For Append As #ff%
        size& = LOF(ff%)
        Close #ff%

        'If it's an empty file, delete it
        If size& = 0 Then Kill TmpFile$: Exit Function

        'Count # of files by reading through list of all
        Open TmpFile$ For Input As #ff%
        Do While Not EOF(ff%) And Index% < ListMAX%
            Index% = Index% + 1
            Line Input #ff%, DirList$(Index%)
        Loop
        Close #ff%
        Kill TmpFile$

        'SHARED variable can return the file count
        FCount% = Index%
    End If

End Function



'-----------------------------------
' FileSize Copycat Function
'-----------------------------------
Function FileSize& (FileName$)
    Open FileName$ For Binary As #1
    FileSize& = LOF(1)
    Close #1
End Function



'-----------------------------------
' FUsing Copycat Function
'-----------------------------------
Function FUsing (Number$, Image$)
    Print Using Number$; Image$
End Function



'-----------------------------------
' MGetKey Copycat Function
'-----------------------------------
Function MGetKey (Row%, Col%)
    'This function is currently not mouse-friendly
    'However, it should return the Row/Col of
    'the mouse cursor when it was clicked

    'Also, it should return the mouse button
    'instead of the keyboard key if mouse
    'was clicked

    'Clear keyboard buffer
    ' ???

    Do
        k$ = InKey$
    Loop Until k$ <> ""
    KeyCode% = CVI(k$ + Chr$(0))

End Function



'-----------------------------------
' Monitor Copycat Function
'-----------------------------------
' This function's original purpose
' was to use ASM to check memory
' addresses to determine the gfx
' adapter and monitor type.
' Modern OS's do not expose this
' and people do not have to worry
' whether they have CGA/EGA/VGA.
' Modern compilers "emulate" these
' features to some degree but that
' does not make this any more relevant.
' So, we're essentially going to return
' 12 for VGA to the functions requesting.
' Currently this is only used in some
' logic to determine print colors and
' will be removed completely in the future.
Function Monitor% ()
    'DEF SEG = 0

    'SupportsColor = PEEK(1123) + 256 * PEEK(1124)
    'Select Case Mono
    '   Case 948: SupportsColor=0
    '   Case 980: SupportsColor=1
    'End Select

    'AdapterType = PEEK...
    'Select Case AdapterType
    '
    'End Select

    'Results to return
    '1 = Mono
    '2 = Hercules
    '3 = CGA
    '4 = EGA Adapter, Monochrome Monitor
    '5 = EGA Adapter, Color Monitor
    '6 = VGA Adapter, Monochrome Monitor
    '7 = VGA Adapter, Color Monitor
    '8 = MCGA Adapter, Monochrome Monitor
    '9 = MCGA Adapter, Color Monitor
    '10 = EGA Adapter, CGA Monitor
    '11 = IBM 8514/A Adapter

    Monitor% = 12
End Function



'-----------------------------------
' OneColor Copycat Function
'-----------------------------------
Function OneColor% (FGColor%, BGColor%)
    'The function below works too
    'OneColor% = (BGColor% * (2 ^ 4)) + (FGColor% \ (2 ^ 4))

    'But this is the doumented function from QPPro
    OneColor% = (FGColor% And 16) * 8 + ((BGColor% And 7) * 16) + (FGColor% And 15)
End Function



'-----------------------------------
' Reads DIR into file list
'-----------------------------------
Function READDIR$ (spec$)
    Const TmpFile$ = "DIR$INF0.INF", ListMAX~& = 131072
    '1024 * 1024 = 4294967295 is the max # of files in a folder
    Shared DirCount% 'returns file count if desired
    Static Ready%, Index%, DirList$()

    If Not Ready% Then ReDim DirList$(ListMAX%): Ready% = -1 'DIM array first use

    If spec$ > "" Then 'get file names when a spec is given
        Shell _Hide "DIR " + spec$ + " /b /on > " + TmpFile$
        Index% = 0: DirList$(Index%) = "": ff% = FreeFile
        Open TmpFile$ For Append As #ff%
        size& = LOF(ff%)
        Close #ff%
        If size& = 0 Then Kill TmpFile$: Exit Function
        Open TmpFile$ For Input As #ff%
        Do While Not EOF(ff%) And Index% < ListMAX%
            Index% = Index% + 1
            Line Input #ff%, DirList$(Index%)
        Loop
        DirCount% = Index% 'SHARED variable can return the file count
        Close #ff%
        Kill TmpFile$
    Else
        If Index% > 0 Then Index% = Index% - 1 'if there's no spec, we get the next file name
    End If
    READDIR$ = DirList$(Index%)
End Function



'-----------------------------------
' AddInt Copycat Subroutine
'-----------------------------------
' NOT IMPLEMENTED
Sub AddInt (AElement, Value, NumEls)
End Sub



' ------------------------------------------------------------
' Subroutine to draw box in Screen Mode 0
' ------------------------------------------------------------
Sub box0 (ULRow%, ULCol%, LRRow%, LRCol%, Char%, Colr%)

    ' TO DO:
    ' Replace print characters with Char%
    '1 = single line all around
    '2 = double line all around
    '3 = double line horizontally, single line vertically
    '4 = single line horizontally, double line vertically
    'If Char% is assigned to any other value, that ASCII character will be used for the entire box.

    Select Case Char%
        Case 1:
            ulCorner$ = Chr$(218)
            horizontal$ = Chr$(196)
            urCorner$ = Chr$(191)
            vertical$ = Chr$(179)
            llCorner$ = Chr$(192)
            lrCorner$ = Chr$(217)
        Case 2:
            ulCorner$ = Chr$(201)
            horizontal$ = Chr$(205)
            urCorner$ = Chr$(187)
            vertical$ = Chr$(186)
            llCorner$ = Chr$(200)
            lrCorner$ = Chr$(188)
        Case 3:
            ulCorner$ = Chr$(201)
            horizontal$ = Chr$(205)
            urCorner$ = Chr$(187)
            vertical$ = Chr$(179)
            llCorner$ = Chr$(200)
            lrCorner$ = Chr$(188)
        Case 4:
            ulCorner$ = Chr$(218)
            horizontal$ = Chr$(196)
            urCorner$ = Chr$(191)
            vertical$ = Chr$(186)
            llCorner$ = Chr$(192)
            lrCorner$ = Chr$(217)
        Case Else:
            ulCorner$ = Chr$(Char%)
            horizontal$ = Chr$(Char%)
            urCorner$ = Chr$(Char%)
            vertical$ = Chr$(Char%)
            llCorner$ = Chr$(Char%)
            lrCorner$ = Chr$(Char%)
    End Select

    Color 15, 1

    ' Prints the top of the box
    Locate ULRow%, ULCol%
    Print ulCorner$ + String$(LRCol% - ULCol%, Asc(horizontal$)) + urCorner$

    ' Print the sides of the box
    For currentRow = (ULRow% + 1) To (LRRow% - 1) Step 1
        Locate currentRow, ULCol%
        Print vertical$ + Space$(LRCol% - ULCol%) + vertical$
    Next

    'Print the bottom line of the box
    Locate LRRow%, ULCol%
    Print llCorner$ + String$(LRCol% - ULCol%, Asc(horizontal$)) + lrCorner$

    Color Colr%,

End Sub



'-----------------------------------
' Print NumLock / CapsLock Status
'-----------------------------------
Sub CapNum ()

    Const NUMLOCK& = 100300
    Const CAPSLOCK& = 100301

    CapStatus = _KeyDown(CAPSLOCK&) 'Get BIOS status of Caps Lock
    NumStatus = _KeyDown(NUMLOCK&) 'Get BIOS status of Num Lock

    H = Pos(0): V = CsrLin 'Save cursor position

    If Cap = CapStatus Then GoTo QNumCheck 'No change since last check

    Cap = CapStatus 'save CapsLock status
    Locate 25, 69 'Position to print status msg

    If CapStatus Then
        Print " CAP " 'White on Black
    Else
        Print Space$(5) 'Print or erase message
    End If


    QNumCheck:
    If Num = NumStatus Then GoTo QCapNumExit 'No change since last check

    Num = NumStatus 'Save NumLock status
    Locate 25, 75 'Position to print status msg

    If NumStatus Then 'Print or erase message
        Print " NUM "
    Else
        Print Space$(5)
    End If

    QCapNumExit:
    Locate V, H 'Restore cursor position
End Sub



'-----------------------------------
' ClearEOL Copycat Subroutine
'-----------------------------------
Sub ClearEOL (FGColor%, BGColor%)
    'Operate from cursor position,
    '  without moving it
    row% = CsrLin
    column% = Pos(0)

    'Start at the cursor position
    Locate row% - 1, column%


    'Print all spaces
    '--If using OneColor:
    '--Color (Colr% And 15), ((Colr% And 240) / 16)
    Color FGColor%, BGColor%
    Print Space$(80 - column%)

End Sub



'-----------------------------------
' Get Command Line Subroutine
'-----------------------------------
Sub Comline (NumArgs%, Args$(), MaxArgs%)
    Const TRUE = -1, FALSE = 0

    NumArgs% = 0: In = FALSE

    ' Get the command line using the COMMAND$ function
    Cl$ = Command$
    L = Len(Cl$)
    ' Go through the command line a character at a time

    For I = 1 To L
        C$ = Mid$(Cl$, I, 1)
        ' Test for character being a blank or a tab
        If (C$ <> " " And C$ <> Chr$(9)) Then
            ' Neither blank nor tab; test if you're already inside
            ' an argument
            If Not In Then
                ' You've found the start of a new argument
                ' Test for too many arguments
                If NumArgs% = MaxArgs% Then Exit For
                NumArgs% = NumArgs% + 1
                In = TRUE
            End If
            ' Add the character to the current argument
            Args$(NumArgs%) = Args$(NumArgs%) + C$
        Else
            ' Found a blank or a tab.
            ' Set "Not in an argument" flag to FALSE
            In = FALSE
        End If
    Next I

End Sub



'-----------------------------------
' ClearScrn + MsgBox Subroutine
'-----------------------------------
Sub CSMsgBox (Message$, Wdth%, Pass)
    If Len(Message$) Then
        Row = CsrLin 'Get the Row Position

        ReDim Temp$(23) 'Make temporary array to hold the parsed up lines

        MesLen = Len(Message$) 'Get the total length of the help message

        LN = 0 'Line number
        Strt = 1 'Starting parse position

        '*** Parse the message into lines
        Do
            While Mid$(Message$, Strt, 1) = " " 'Skip over blanks
                Strt = Strt + 1
            Wend
            ND = Strt + Wdth 'Guess at the end of line
            'Loop backwards to find
            While Mid$(Message$, ND, 1) <> " " And ND <= MesLen And ND > Strt
                ND = ND - 1 '  blank space
            Wend
            LN = LN + 1 'Increment the Line number
            'Pull out the new line
            Temp$(LN) = Mid$(Message$, Strt, ND - Strt)
            Strt = ND + 1 'Reset starting posit. for
            '  next line
        Loop Until ND >= MesLen 'Get more unless @ end of mes
        BotRow = Row + LN + 1 'Find the bottom row #

        'Save current screen
        'oldScrn& = _CopyImage(0)
        PCopy 0, 1

        BoxWdth = Wdth + 4 'Find the outer box width
        ColPos = 40 - (BoxWdth \ 2) 'Starting pos. for centered box
        Locate Row, ColPos 'Print the top of box


        MQPrint "É" + String$(Wdth + 2, "Í") + "»", 0, 7

        Box$ = "º" + Space$(Wdth + 2) + "º" 'Make the box sides

        For N = 1 To LN 'Print message lines
            Locate N + Row, ColPos
            MQPrint Box$, 0, 7
            Locate , ColPos + 2
            MQPrint Temp$(N), 0, 7
        Next

        Locate N + Row, ColPos 'Print the bottom of box
        MQPrint "È" + String$(Wdth + 2, "Í") + "¼", 0, 7

        'MPaintBox Row + 1, ColPos + BoxWdth, N + Row, ColPos + BoxWdth + 1, 8
        'MPaintBox N + Row + 1, ColPos + 2, N + Row + 1, ColPos + BoxWdth + 1, 8
        Locate Row,

        Pass = 1 'Set flag say we've been here
        Erase Temp$ 'Don't need this anymore

    ElseIf Pass = 1 Then 'If we've been here before...
        'Restore the original screen
        PCopy 1, 0

        Pass = 0 'Reset flag for next call
    End If

End Sub



'-----------------------------------
' FCopy Copycat Subroutine
'-----------------------------------
Sub FCopy (srcFile$, dstFile$, Buff$, copyErr%)

    If _FileExists(srcFile$) Then

        If _FileExists(dstFile$) Then
            'issue with detination
            copyErr% = 2
            'KILL dstFile$
        End If

        ffSrc = FreeFile
        Open srcFile$ For Binary As ffSrc
        ffDst = FreeFile
        Open dstFile$ For Binary As ffDst

        size& = LOF(ffSrc)
        BufferSize& = 1024
        Buff$ = Space$(BufferSize&)
     
        For o& = 1 To size& Step BufferSize&
            If o& + BufferSize& - 1 > size& Then Buffer$ = Space$(size& - o& + 1)
            Get ffSrc, , Buff$
            Put ffDst, , Buff$
            '_DELAY BufferSize& / BytesPerSecond&
        Next
        'Copy is OK
        copyErr% = 0

        Close ffSrc
        Close ffDst
    Else
        'Issue with source
        copyErr% = 1
    End If

End Sub

 

'-----------------------------------
' InitInt Copycat Subroutine
'-----------------------------------
Sub InitInt (AElement, StartValue, NumEls)
    ' NOT IMPLEMENTED / OBSOLETE
End Sub



'-----------------------------------
' ISortI Copycat Subroutine
'-----------------------------------
Sub ISortI (Element%, IndexElement%, NumElements%, Direction%)
    ' NOT IMPLEMENTED / OBSOLETE
End Sub



'-----------------------------------
' Lts2Menu Subroutine
'-----------------------------------
Sub Lts2Menu (Item$(), Prompt$(), Choice%, Colr%)
    'Item$() and Prompt$() have oneDIMension
    'Choice% is the value returned, or zero if Escape is pressed
    'Colr% is the packed color to use for the display
    '
    'NOTE: The foreground and background portions of Colr% are reversed for
    '      the highlighted item.  Also, a new color is derived from Colr%
    '      for the prompt message - change this to suit by searching for
    '      the string "prompt color".
    '
    'NOTE: A comment near the end shows how to modify this menu to exit
    '      when a letter key is pressed, without also needing to press Enter.
    '      If you do this, each item should start with a unique first letter.
    '      Search for the string "having" to find where.

    Locate , , 0 'turn off the cursor
    SplitColor Colr%, FG%, BG% 'split color into FG and BG
    ReDim ScrBuf%(0 To 159)
    TRow% = CsrLin
    '--Need to update below with correct code
    'ScrnSave0 TRow%, 1, TRow% + 1, 80, ScrBuf%(0)

    Call ClearEOL(FG%, BG%) 'clear any old prompt information

    '-- determine how many choices there are
    NumItems% = UBound(Item$) 'get the number of items passed
    While Item$(NumItems%) = "" 'seek the last non-blank item
        NumItems% = NumItems% - 1
    Wend
    ReDim Break%(NumItems% + 1) 'remembers which items start on a new screen
    Break%(NumItems% + 1) = -2 'mark one past the end as a flag
    Col% = 1 'tracks the accumulated line width and columns
    Page% = 1 'tracks which item begins a new screen page

    '-- Build a table of starting columns and page breaks for each item.
    '   For each item that begins a new page, use a negative version of the
    '   page number as a flag.  we don't need the starting column for those
    '   anyway, because the first item on each pagwe always is in column 1.
    '   For all other items, the equivalent Break%() element will hold the
    '   column in which this item is located.
    For X% = 1 To NumItems%
        Break%(X%) = Col% 'assume we're not starting a new screen page
        If X% = 1 Then Break%(X%) = -1
        Col% = Col% + Len(Item$(X%)) + 2 'add two for a small border
        If Col% > 80 Then
            Page% = Page% + 1 'we advanced to the next page
            Break%(X%) = -Page% 'this item starts a page, remember which one
            Col% = Len(Item$(X%)) + 3
        End If
    Next

    '-- print a page-full of items
    Choice% = 1 'start with item 1 the first time

    QPPrintLt2:
    X% = Choice% 'assume we'll start at the current item
    While Break%(X%) > 0 'seek the first item on this page
        X% = X% - 1
    Wend
    Do 'print until the negative Break%() flag
        C% = Colr% 'assume the item being printed is NOT current
        CH% = 12
        If X% = Choice% Then 'we were wrong, reverse the FG and BG colors
            C% = OneColor%(BG%, FG% And 7)
            CH% = C%
            Locate CsrLin + 1, 1 'go down a line and to the first column
            Call ClearEOL(FG%, BG%) 'clear any old prompt information
            'you may adjust the prompt color by changing the line below
            test$ = Space$(1) + Prompt$(X%) + Space$(1)
            QPrint test$, FG%, BG%, -1
            Locate CsrLin - 1 'return to the line above
        End If
        If Break%(X%) < 0 Then 'if it's the first item on this page
            Locate , 1 'locate to the first column
            If ClearFlag% Then 'if we just crossed a page boundary
                Call ClearEOL(FG%, BG%) '  clear any old items that may still show
                ClearFlag% = 0
            End If
        Else 'otherwise
            Locate , Break%(X%) '  locate to the correct column
        End If
        If Break%(X%) < 0 Then
            '--Need to update below with colors
            'QPrint SPACE$(1) + left$(Item$(X%),1) + SPACE$(1), CH%, -1
            Locate , 3
            '--Need to update below with colors
            'QPrint right$(Item$(X%),len(item$(x%))-1) + SPACE$(1), C%, -1
        Else
            '--Need to update below with colors
            'QPrint SPACE$(1) + left$(Item$(X%),1) + SPACE$(1), CH%, -1
            Locate , Break%(X%) + 2
            '--Need to update below with colors
            'QPrint right$(Item$(X%),len(item$(x%))-1) + SPACE$(1), C%, -1
        End If
        X% = X% + 1 'advance to the next item
    Loop Until Break%(X%) < -1
    Do
        X$ = GetKeyPress$
    Loop Until Len(X$)
    If Len(X$) = 2 Then 'extended key
        Select Case Asc(Right$(X$, 1))
            Case 71 'Home Key
                Choice% = 1 'set to the first item in the list
                ClearFlag% = 1 'flag to clear old items
            Case 75 'Left Arrow
                If Choice% > 1 Then
                    Choice% = Choice% - 1
                    If Break%(Choice%) < 0 Then ClearFlag% = 1
                Else
                    Choice% = NumItems%
                    ClearFlag% = 1
                End If
            Case 77 'Right Arrow
                If Choice% < NumItems% Then
                    Choice% = Choice% + 1
                    If Break%(Choice%) < 0 Then ClearFlag% = 1
                Else
                    Choice% = 1
                    ClearFlag% = 1
                End If
     
            Case 79 'End Key
                Choice% = NumItems%
                ClearFlag% = 1
            Case Else
        End Select
    Else
        Select Case X$
            Case Chr$(13) 'Enter Key
                GoTo QPExitLt2 'exit with the current choice
            Case Chr$(27) 'Escape Key
                Choice% = 0 'set the choice to zero as an Escape flag
                GoTo QPExitLt2
            Case Else 'they must be typing a choice's first letter
                X% = Choice% 'scan through each item looking for a match
                Do 'starting at the item after the current one
                    If X% = NumItems% Then X% = 0 'wrap past the last one
                    X% = X% + 1 'consider the next item
                    If Asc(UCase$(Item$(X%))) = Asc(UCase$(X$)) Then
                        Choice% = X% 'we found one, save where
                        ClearFlag% = 1 'set flag to clear old stuff
                        'EXIT DO                      '  and stop searching
                        GoTo QPExitLt2
                        'change the EXIT DO above to GOTO QPExitLt2 to exit without
                        '  having to press Enter
                    End If
                    If X% = Choice% Then Exit Do 'we already went around once
                Loop
        End Select
    End If
    GoTo QPPrintLt2

    QPExitLt2:
    '--Need to update below with correct code
    'ScrnRest0 TRow%, 1, TRow% + 1, 80, ScrBuf%(0)
    Erase Break%, ScrBuf%

End Sub



'-----------------------------------
' MAMenu Copycat Subroutine
'-----------------------------------
Sub MAMenu (menuItems$(), Selected%, Start%, Count%, ScanCode%, ItemFGColor%, ItemBGColor%, HighlightFGColor%, HighlightBGColor%, NumRows%, NumCols%, Spacing%, Row%, Column%)
    'Selected%
    ' which element to put at the top of the menu

    'Start%
    ' which element to put at the top of the menu

    'Count%
    'Total number of elements to print

    'ScanCode%
    ' the key used to exit the menu
    ' normal keys = positive values; extended keys = negative values
    ' ie, 13 = Enter; -59 = F1

    'ItemColor%, HighlightColor%
    ' color values to use for menu items and the highlighted menu item, respectively

    'NumRows%
    'Number of rows to print

    ' Spacing%
    ' Spacing between elements in each column

    ' Row% / Column%
    ' row / column from which to start printing

    _MouseHide

    'Determine our limits for # screens / rows
    currentScreen% = 1
    colMaxItems% = NumRows% - 3
    MaxScreenItems% = colMaxItems% * NumCols%
    screenStartItem = 1
    screenEndItem = MaxScreenItems%

    '--- this should be assigned based on the
    '--- length of the first element in the array
    elementLength = 15

    'value between 1st column and 4th column -- left and right arrow routines
    colDiff% = colMaxItems% * (Row% - 1)

    MaxScrnNum% = Int(Count% / MaxScreenItems%)
    If (MaxScreenItems% Mod Count%) <> 0 Then
        MaxScrnNum% = MaxScrnNum% + 1
    End If

    'Currently this routine is NOT mouse-friendly

    'Basically just need to consider # of columns
    'Loop through them and print a row for each one
    'Also move "column" to print at based on spacing

    If ScanCode% = 0 Then ScanCode% = NumRows%

    If NumRows% > ScanCode% Then
        NumRows% = ScanCode%
    End If

    currentChoice = Selected%

    ' Output menu options first
    ItemIndex = Start%

    'For itemIndex = Start% To (Start% + Count% - 1)

    For colIndex = Column% To NumCols%

        For rowIndex = Row% To NumRows% Step 1

            PrintColumn = Column% + ((colIndex - 1) * (elementLength + Spacing%))
            Locate rowIndex, PrintColumn

            'If we did not start at the 1st position, we're going to
            'loop back around in our array to the beginning elements

            If ItemIndex = Selected% Then
                ' Print the specified item in the menu, highlighted
                Color HighlightFGColor%, HighlightBGColor%
                Print String$(elementLength + Spacing%, " ")
                Locate rowIndex, PrintColumn
            Else
                Color ItemFGColor%, ItemBGColor%
            End If

            Print menuItems$(ItemIndex)

            ItemIndex = ItemIndex + 1
            If ItemIndex > UBound(menuItems$) Then ItemIndex = LBound(menuItems$)

        Next rowIndex

    Next colIndex

    userRow = Row%
    userCol = Column%

    ' Read user input, only act on up/down/ENTER
    Do: Selection$ = InKey$
        If Selection$ <> "" Then
            ScanCode% = Asc(Selection$)
            Select Case Selection$
                Case Chr$(0) + "H": GoSub Up.Arrow
                Case Chr$(0) + "P": GoSub Down.Arrow
                Case Chr$(0) + "K": GoSub Left.Arrow
                Case Chr$(0) + "M": GoSub Right.Arrow
                Case Chr$(0) + "I": GoSub Page.Up
                Case Chr$(0) + "Q": GoSub Page.Down
            End Select
        End If
    Loop Until Selection$ = Chr$(13) Or Selection$ = Chr$(27)

    If Selection$ = Chr$(27) Then
        currentChoice = 0
    End If

    Color HighlightBGColor%, HighlightFGColor%
    Selected% = currentChoice

    Exit Sub

    Up.Arrow:

    If currentChoice > screenStartItem Then
        PrintColumn = Column% + ((elementLength + Spacing%) * (userCol - 1))
        ' Print menu item w/o highlight, below where we just moved to
        Locate userRow, PrintColumn
        Color ItemFGColor%, ItemBGColor%
        If PrintColumn < 64 Then
            Print String$(elementLength + Spacing%, " ")
        Else: Print String$(elementLength + Spacing2%, " ")
        End If
        Locate userRow, PrintColumn
        Print menuItems$(currentChoice)
        userRow = userRow - 1

        'Move to previous column
        If (userRow Mod NumRows%) < Row% Then
            If userCol > 1 Then
                userCol = userCol - 1
                userRow = NumRows%
            End If

            PrintColumn = Column% + ((elementLength + Spacing%) * (userCol - 1))
        End If

        'We've technically chosen the previous entry
        currentChoice = currentChoice - 1
        ' Highlight the new menu item
        Locate userRow, PrintColumn
        Color HighlightFGColor%, HighlightBGColor%:
        If PrintColumn < 64 Then
            Print String$(elementLength + Spacing%, " ")
            Locate userRow, PrintColumn
            Print menuItems$(currentChoice)

        Else: Print String$(elementLength + Spacing2%, " ")
            Locate userRow, PrintColumn
            Print menuItems$(currentChoice)
        End If
    End If: Return

    Down.Arrow:

    If currentChoice < screenEndItem And currentChoice < Count% Then
        PrintColumn = Column% + ((elementLength + Spacing%) * (userCol - 1))
        ' Print menu item w/o highlight, above where we just moved to
        Locate userRow, PrintColumn
        Color ItemFGColor%, ItemBGColor%
        If PrintColumn < 64 Then
            Print String$(elementLength + Spacing%, " ")
            Locate userRow, PrintColumn
            Print menuItems$(currentChoice)
        Else: Print String$(elementLength + Spacing2%, " ")
            Locate userRow, PrintColumn
            Print menuItems$(currentChoice)
        End If
        userRow = userRow + 1

        'Move to next column
        If (userRow Mod NumRows%) = 1 Then
            userCol = userCol + 1
            PrintColumn = Column% + ((elementLength + Spacing%) * (userCol - 1))
            userRow = Row%
        End If

        'We've technically chosen the next entry
        currentChoice = currentChoice + 1
        ' Highlight the new menu item
        Locate userRow, PrintColumn
        Color HighlightFGColor%, HighlightBGColor%
        If PrintColumn < 64 Then
            Print String$(elementLength + Spacing%, " ")
            Locate userRow, PrintColumn
            Print menuItems$(currentChoice)

        Else: Print String$(elementLength + Spacing2%, " ")
            Locate userRow, PrintColumn
            Print menuItems$(currentChoice)
        End If
    End If: Return:

    Left.Arrow:

    If currentChoice > screenStartItem And currentChoice <= screenEndItem Then

        If currentScreen% = MaxScrnNum% Then

            'Determines last column on final screen
            If Count% - screenStartItem + 1 <= colMaxItems% Then
                finalMaxCols = 1: Return
            Else
                finalMaxCols = Int((Count% - screenStartItem + 1) / colMaxItems%)
                If (finalMaxCols Mod Count%) <> 0 Then
                    finalMaxCols = finalMaxCols + 1
                    MaxRowOnFinalColumn = Row% + (finalMaxCols Mod Count%)
                End If
            End If
            NumCols% = finalMaxCols
            colDiff% = colMaxItems% * (NumCols% - 1)
        End If

        If userCol = Column% Then
            PrintColumn = Column% + ((elementLength + Spacing%) * (userCol - 1))
            Locate userRow, PrintColumn: Color ItemFGColor%, ItemBGColor%
            Print String$(elementLength + Spacing%, " ")
            Locate userRow, PrintColumn: Print menuItems$(currentChoice)

            userCol = NumCols%
            If currentScreen% = MaxScrnNum% Then
                If currentChoice + colDiff% > Count% Then
                    currentChoice = Count% + 1
                    userRow = MaxRowOnFinalColumn
                End If
            End If
            If currentChoice + colDiff% <= Count% Then
                currentChoice = currentChoice + colDiff%
            End If
            GoSub Up.Arrow: Return
        End If

        PrintColumn = Column% + ((elementLength + Spacing%) * (userCol - 1))

        ' Print menu item w/o highlight, right to where we just moved to
        Locate userRow, PrintColumn
        Color ItemFGColor%, ItemBGColor%
        If PrintColumn < 64 Then
            Print String$(elementLength + Spacing%, " ")
            Locate userRow, PrintColumn
            Print menuItems$(currentChoice)
        Else
            Print String$(elementLength + Spacing2%, " ")
            Locate userRow, PrintColumn
            Print menuItems$(currentChoice)
        End If

        userCol = userCol - 1

        'Move to previous Column
        PrintColumn = Column% + ((elementLength + Spacing%) * (userCol - 1))

        currentChoice = currentChoice - colMaxItems%

        Locate userRow, PrintColumn ' Highlight the new menu item
        Color HighlightFGColor%, HighlightBGColor%
        Print String$(elementLength + Spacing%, " ")
        Locate userRow, PrintColumn
        Print menuItems$(currentChoice)
    End If: Return

    Right.Arrow:

    If currentChoice >= screenStartItem And currentChoice < screenEndItem Then

        If currentScreen% = MaxScrnNum% Then
            If (currentChoice + colMaxItems%) > Count% Then
                Return
            End If
        End If

        If userCol = NumCols% Then
            PrintColumn = Column% + ((elementLength + Spacing%) * (userCol - 1))
            Locate userRow, PrintColumn: Color ItemFGColor%, ItemBGColor%
            Print String$(elementLength + Spacing2%, " ")
            Locate userRow, PrintColumn
            Print menuItems$(currentChoice)

            userCol = Column%: PrintColumn = Column%
            currentChoice = currentChoice - colDiff%
            GoSub Down.Arrow: Return
        End If

        PrintColumn = Column% + ((elementLength + Spacing%) * (userCol - 1))

        ' Print menu item w/o highlight, left to where we just moved to
        Locate userRow, PrintColumn
        Color ItemFGColor%, ItemBGColor%
        If PrintColumn < 64 Then
            Print String$(elementLength + Spacing%, " ")
            Locate userRow, PrintColumn
            Print menuItems$(currentChoice)
        Else
            Print String$(elementLength + Spacing2%, " ")
            Locate userRow, PrintColumn
            Print menuItems$(currentChoice)
        End If

        userCol = userCol + 1

        'Move to next Col
        PrintColumn = Column% + ((elementLength + Spacing%) * (userCol - 1))

        'We've technically chosen the next entry
        currentChoice = currentChoice + colMaxItems%

        ' Highlight the new menu item
        Locate userRow, PrintColumn
        Color HighlightFGColor%, HighlightBGColor%

        If PrintColumn < 64 Then
            Print String$(elementLength + Spacing%, " ")
            Locate userRow, PrintColumn
            Print menuItems$(currentChoice)

        Else: Print String$(elementLength + Spacing2%, " ")
            Locate userRow, PrintColumn
            Print menuItems$(currentChoice)
        End If
    End If: Return

    Page.Up:

    If currentScreen% > 1 Then
        Color , 4: Cls: Locate , 33: Color 14
        Print "TEAM SELECTION": Color 15
        Locate 25, 1: Color 14: Print "ESC";: Color 15
        Print "-SELECT NEW ID  PGDN  PGUP  ";: Color 14
        Print "ENTER";: Color 15: Print "-SELECTS TEAM";
        userRow = Row%: userCol = Column%

        currentScreen% = currentScreen% - 1
        screenStartItem = screenStartItem - MaxScreenItems%
        screenEndItem = screenStartItem + (MaxScreenItems% - 1)
        ItemIndex = screenStartItem
        Selected% = ItemIndex

        For colIndex = Column% To NumCols%

            For rowIndex = Row% To NumRows% Step 1

                PrintColumn = Column% + ((colIndex - 1) * (elementLength + Spacing%))
                Locate rowIndex, PrintColumn

                'If we did not start at the 1st position, we're going to
                'loop back around in our array to the beginning elements

                If ItemIndex = Selected% Then
                    ' Print the specified item in the menu, highlighted
                    Color 0, HighlightColor%
                    Print String$(elementLength + Spacing%, " ")
                    Locate rowIndex, PrintColumn
                Else: Color ItemFGColor%, ItemBGColor%
                End If

                Print menuItems$(ItemIndex)

                ItemIndex = ItemIndex + 1
                If ItemIndex > UBound(menuItems$) Then ItemIndex = LBound(menuItems$)

            Next rowIndex

        Next colIndex: currentChoice = Selected%
    End If: Return

    Page.Down:

    Selected% = ItemIndex ' makes sure the 1st item on page gets highlighted

    If currentScreen% < MaxScrnNum% Then
        Color , 4: Cls: Locate , 33: Color 14
        Print "TEAM SELECTION": Color 15
        Locate 25, 1: Color 14: Print "ESC";: Color 15
        Print "-SELECT NEW ID  PGDN  PGUP  ";: Color 14
        Print "ENTER";: Color 15: Print "-SELECTS TEAM";
        userRow = Row%: userCol = Column%

        For colIndex = Column% To NumCols%

            For rowIndex = Row% To NumRows% Step 1

                PrintColumn = Column% + ((colIndex - 1) * (elementLength + Spacing%))
                Locate rowIndex, PrintColumn

                'If we did not start at the 1st position, we're going to
                'loop back around in our array to the beginning elements

                If ItemIndex = Selected% Then
                    ' Print the specified item in the menu, highlighted
                    Color HighlightFGColor%, HighlightBGColor%
                    Print String$(elementLength + Spacing%, " ")
                    Locate rowIndex, PrintColumn
                Else: Color ItemFGColor%, ItemBGColor%
                End If

                Print menuItems$(ItemIndex)

                ItemIndex = ItemIndex + 1
                If ItemIndex > UBound(menuItems$) Then ItemIndex = LBound(menuItems$)

            Next rowIndex

        Next colIndex

        If currentScreen% = 1 Then
            currentChoice = 1
        End If

        currentChoice = (MaxScreenItems% * currentScreen%) + 1
        currentScreen% = currentScreen% + 1
        screenStartItem = currentChoice
        screenEndItem = screenStartItem + (MaxScreenItems% - 1)

    End If: Return

End Sub



'-----------------------------------
' MMenuVert Copycat Subroutine
'-----------------------------------
Sub MMenuVert (menuItems$(), Selected%, Start%, ScanCode%, ItemFGColor%, ItemBGColor%, HighlightFGColor%, HighlightBGColor%, NumRows%, Row%, Column%)
    'Selected%
    ' which element to put at the top of the menu

    'Start%
    ' which element to put at the top of the menu

    'ScanCode%
    ' the key used to exit the menu
    ' normal keys = positive values; extended keys = negative values
    ' ie, 13 = Enter; -59 = F1

    'ItemColor%, HighlightColor%
    ' color values to use for menu items and the highlighted menu item, respectively

    'NumRows%
    'Number of rows to print

    ' Row% / Column%
    ' row / column from which to start printing
    _MouseHide

    '--- this should be assigned based on the
    '--- length of the first element in the array
    itemLength = 32
    If ScanCode% = 0 Then ScanCode% = NumRows%

    If NumRows% > ScanCode% Then
        NumRows% = ScanCode%
    End If

    currentChoice = Selected%
    itemIndex = Start%

    For rowIndex = 1 To NumRows% Step 1

        'If we did not start at the 1st position, we're going to
        'loop back around in our array to the beginning elements
        Locate rowIndex + Row% - 1, Column%

        If itemIndex = Selected% Then
            ' Print the specified item in the menu, highlighted
            '--If using OneColor, use the below
            '--Color (HighlightColor% And 15), ((HighlightColor% And 240) / 16)
            Color HighlightFGColor%, HighlightBGColor%
            Print String$(itemLength, " ")
            Locate rowIndex + Row% - 1, Column%
        Else
            '--If using OneColor, use the below
            '--Color (ItemColor% And 15), ((ItemColor% And 240) / 16)
            Color ItemFGColor%, ItemBGColor%
        End If

        Print menuItems$(itemIndex)
        itemIndex = itemIndex + 1
        If itemIndex > UBound(menuItems$) Then itemIndex = LBound(menuItems$)

    Next rowIndex

    ' Read user input, only act on Up/Down
    Do:
        Selection$ = InKey$
        If Selection$ <> "" Then
            ScanCode% = Asc(Selection$)
            Select Case Selection$
                Case Chr$(0) + "H": GoSub Up.Arrow
                Case Chr$(0) + "P": GoSub Down.Arrow
            End Select
        End If
        ' End when user presses Enter/Esc
    Loop Until Selection$ = Chr$(13) Or Selection$ = Chr$(27)

    'ESC means we made no choice
    If Selection$ = Chr$(27) Then
        currentChoice = 0
    End If

    '--If using OneColor, use the below
    '--Color (HighlightColor% And 15), ((HighlightColor% And 240) / 16)
    Color HighlightFGColor%, HighlightBGColor%
    Selected% = currentChoice

    _MouseShow "DEFAULT"
    Exit Sub

    Up.Arrow:
    If currentChoice > 1 And currentChoice < NumRows% + 1 Then
        ' Print menu item w/o highlight, above where we just moved to
        Locate Row%, Column%
        '--If using OneColor, use the below
        '--Color (ItemColor% And 15), ((ItemColor% And 240) / 16)
        Color ItemFGColor%, ItemBGColor%
        Print String$(itemLength, " ")
        Locate Row%, Column%: Print menuItems$(currentChoice): Row% = Row% - 1
        ' Highlight the new menu item
        currentChoice = currentChoice - 1
        Locate Row%, Column%
        '--If using OneColor, use the below
        '--Color (HighlightColor% And 15), ((HighlightColor% And 240) / 16)
        Color HighlightFGColor%, HighlightBGColor%
        Print String$(itemLength, " ")
        Locate Row%, Column%: Print menuItems$(currentChoice)
    End If: Return

    Down.Arrow:
    If currentChoice < NumRows% Then
        ' Print menu item w/o highlight, above where we just moved to
        Locate Row%, Column%
        '--If using OneColor, use the below
        '--Color (ItemColor% And 15), ((ItemColor% And 240) / 16)
        Color ItemFGColor%, ItemBGColor%
        Print String$(itemLength, " ")
        Locate Row%, Column%: Print menuItems$(currentChoice): Row% = Row% + 1
        ' Highlight the new menu item
        currentChoice = currentChoice + 1
        Locate Row%, Column%
        '--If using OneColor, use the below
        '--Color (HighlightColor% And 15), ((HighlightColor% And 240) / 16)
        Color HighlightFGColor%, HighlightBGColor%
        Print String$(itemLength, " ")
        Locate Row%, Column%: Print menuItems$(currentChoice)
    End If: Return:

End Sub



'-----------------------------------
' MPaintBox Copycat Subroutine
'-----------------------------------
Sub MPaintBox (ULRow%, ULCol%, LRRow%, LRCol%, Colr%)
    _MouseHide

    _MouseShow "DEFAULT"
End Sub



'-----------------------------------
' MQPrint Copycat Subroutine
'-----------------------------------
Sub MQPrint (X$, FGColor%, BGColor%)
    _MouseHide
    H = Pos(0): V = CsrLin 'save cursor position
    '--If using OneColor:
    '--Color (Colr% And 15), ((Colr% And 240) / 16)
    Color FGColor%, BGColor%
    Print X$
    Locate V, H
    _MouseShow "DEFAULT"
End Sub



'-----------------------------------
' QuickSort Subroutine
'-----------------------------------
Sub QuickSort (start As Integer, finish As Integer, array() As Single)
    Dim Hi As Integer, Lo As Integer, Middle As Single
    Hi = finish: Lo = start
    Middle = array((Lo + Hi) / 2) 'find middle of array
    Do
        Do While array(Lo) < Middle: Lo = Lo + 1: Loop
        Do While array(Hi) > Middle: Hi = Hi - 1: Loop
        If Lo <= Hi Then
            Swap array(Lo), array(Hi)
            Lo = Lo + 1: Hi = Hi - 1
        End If 'If homework, you will fail
    Loop Until Lo > Hi
    If Hi > start Then Call QuickSort(start, Hi, array())
    If Lo < finish Then Call QuickSort(Lo, finish, array())
End Sub



'-----------------------------------
' NumIn Copycat Subroutine
'-----------------------------------
Sub NumIn (INJ%( i), Max, XCode, Colr)
End Sub



'-----------------------------------
' QPrint Copycat Subroutine
'-----------------------------------
Sub QPrint (X$, FGColor%, BGColor%, Page%)
    ' X$
    ' The string to print

    'FGColor/BGColor
    'The colors to use for printing

    'Page
    'The screen page to print to
    '--currently NOT used
    'Screen 0, Page%,

    'Save cursor position
    H = Pos(0): V = CsrLin

    'The actual printing
    '--If using OneColor:
    '--Color (Colr% And 15), ((Colr% And 240) / 16)
    Color FGColor%, BGColor%
    Print X$

    'Restore cursor position
    Locate V, H
End Sub



'-----------------------------------
' ReadFile Copycat Subroutine
'-----------------------------------
Sub ReadFile (fileList$())

    TmpFile$ = "temp" + Time$ + ".tmp"
    Mid$(TmpFile$, 7, 1) = "-"
    Mid$(TmpFile$, 10, 1) = "-"
    fileSpec$ = fileList$(0)

    'We'll use shell commands and specify a sort-by-name
    'This replaces the need to sort the list afterwards
    opSys$ = _OS$
    y% = Len(s$)
    osSpec$ = Left$(_OS$, InStr(2, _OS$, "[") - 1)

    Select Case osSpec$
        Case "[WINDOWS]": Shell _Hide "dir /on /b" + fileSpec$ + " > " + TmpFile$
        Case "[MAC]": Shell _Hide "find . -iname fileSpec$ -type f -print0 | sort -z | tee TmpFile"
        Case "[LINUX]": Shell _Hide "find . -iname fileSpec$ -type f -print0 | sort -z | tee TmpFile$'"
    End Select

    dirEntry = 0
    Open tem$ For Input As #5
    While Not EOF(5)
        Line Input #5, x$
        dirEntry = dirEntry + 1
        fileList$(dirEntry) = x$
    Wend
    Close 5
    Kill tem$
End Sub



'-----------------------------------
' SplitColor Copycat Subroutine
'-----------------------------------
Sub SplitColor (Colr%, FG%, BG%)

    'Reversing FG Color
    FG% = (Colr% And 15)

    'Reversing BG Color
    BG% = ((Colr% And 240) / 16)

End Sub



'-----------------------------------
' Text Input Subroutine
'-----------------------------------
Sub TextIn (T$, Max%, NumOnly%, CapsOn%, ExitCode%, FGColor%, BGColor%)

    TInitialize:
    Clr = 0 'Determine monitor type

    Def Seg = 0
    If Peek(&H463) <> &HB4 Then Clr = 1

    X$ = T$ 'Work on a copy of the string
    '  X$ = QPTrim$(T$)     'Use this if incoming tring is fixed-length

    TC:
    ExitCode% = 0: Insrt = 0: CursorPos = 1 'Initialize flags

    Length = Len(X$)
    If Length > Max% Then Exit Sub 'Too big to edit anymore!

    X$ = X$ + Space$(Max% - Length) 'Pad with trailing spaces

    Locate , , 1 'Toggle the cursor
    Call QPrint(X$, FGColor%, BGColor%, -1)
    ' Locate , , 1  'Toggle the cursor

    GoSub TInsertOff 'Set cursor size according to display


    TGetKey:
    Call CapNum 'display Cap/Num if active

    'Prevent INSERT if cursor is past the end
    If CursorPos > Length And Insrt <> 0 Then GoSub TInsertOff
    If CursorPos > Max% GoTo TEnter 'field is filled, handle as Enter key

    A$ = InKey$
    If A$ = "" GoTo TGetKey
    If Len(A$) = 1 GoTo TRegularKey

    A$ = Right$(A$, 1) 'it was an extended key, get the code
    On InStr(Chr$(15) + ".GHKMOPRSstu" + Chr$(19), A$) GOTO TShiftTab, TClear, THome, TUp, TLeft, TRight, TEndKey, TDown, TIns, TDel, TCtrlLeft, TCtrlRight, TCtrlEnd, TRestore
    GoTo TGetKey 'none of the above, get again


    TShiftTab:
    ExitCode% = 1 'User wants to go to previous field
    GoTo TEnter 'Behavior is similar to the Enter key


    TClear:
    X$ = "" 'Alt-C, erase the current string
    GoSub TInsertOff 'clear insert mode and restore cursor
    Locate , Pos(0) - (CursorPos - 1)
    GoTo TC 'and start all over again


    THome:
    Locate , Pos(0) - (CursorPos - 1) 'put cursor at beginning of line
    CursorPos = 1 'show cursor as being on 1st character
    GoTo TGetKey


    TUp:
    ExitCode% = 1 'user wants to go back a field
    GoTo TEnter 'handle as if it were the Enter key


    TLeft:
    If CursorPos = 1 GoTo TShiftTab 'cursor is on 1st character, handle as Shift-Tab
    CursorPos = CursorPos - 1 'update cursor position
    Locate , Pos(0) - 1 'back up the cursor
    GoTo TGetKey

    TRight:
    CursorPos = CursorPos + 1 'update cursor position
    Locate , Pos(0) + 1 'advance the cursor on the screen
    GoTo TGetKey

    TEndKey:
    Locate , Pos(0) + (Length - CursorPos) + 1 'put cursor at the end of the line
    CursorPos = Length + 1 'update cursor position
    GoTo TGetKey

    TDown:
    GoTo TEnter

    TIns:
    If Insrt Then 'insert is already on, turn it off
        GoSub TInsertOff
        GoTo TGetKey
    End If

    If CursorPos > Length GoTo TGetKey 'ignore Ins if cursor is past the end
    If Length = Max% GoTo TGetKey 'also ignore if field is full

    Insrt = 1 'set the insert flag
    If Clr Then 'set cursor size according to display
        Locate , , , 0, 7
    Else
        Locate , , , 0, 13
    End If

    GoTo TGetKey

    TDel:
    If CursorPos > Length GoTo TGetKey 'ignore Del if cursor is past end

    'slide all characters left one position, add a trailing space and re-print
    Mid$(X$, CursorPos) = Mid$(X$, CursorPos + 1) + " "
    Call QPrint(Mid$(X$, CursorPos), FGColor%, BGColor%, -1)

    Length = Length - 1 'show string as one character shorter
    GoTo TGetKey

    TCtrlLeft:
    If CursorPos = 1 GoTo TGetKey 'at the beginning, ignore

    A = CursorPos 'save cursor position

    'we're within a word, find beginning
    If Mid$(X$, CursorPos - 1, 1) <> " " GoTo TSeekLeft2

    TSeekLeft1:
    If CursorPos = 1 GoTo TCtrlLeftExit 'at the beginning, give up

    If Mid$(X$, CursorPos - 1, 1) = " " Then
        CursorPos = CursorPos - 1
        GoTo TSeekLeft1 'seek previous non-blank character
    End If

    TSeekLeft2:
    If CursorPos = 1 GoTo TCtrlLeftExit 'at the beginning, give up
    If Mid$(X$, CursorPos - 1, 1) <> " " Then
        CursorPos = CursorPos - 1
        GoTo TSeekLeft2 'seek character preceeded by a blank
    End If

    TCtrlLeftExit:
    Locate , Pos(0) - (A - CursorPos) 'position the cursor
    GoTo TGetKey

    TCtrlRight:
    A = CursorPos 'save cursor position

    TSeekRight1:
    If A > Length GoTo TGetKey 'at the end, give up

    If Mid$(X$, A, 1) <> " " Then
        A = A + 1 'consider next character
        GoTo TSeekRight1 'seek next blank space
    End If

    TSeekRight2:
    If A > Length GoTo TGetKey 'at the end, give up

    If Mid$(X$, A, 1) = " " Then
        A = A + 1 'consider next character
        GoTo TSeekRight2 'seek next non-blank character
    End If

    Locate , Pos(0) + (A - CursorPos) 'position the cursor

    CursorPos = A 'show cursor as being on the next word
    GoTo TGetKey 'get another keypress

    TCtrlEnd:
    If CursorPos > Length GoTo TGetKey 'cursor is past the end, ignore

    Call QPrint(Space$(Length - CursorPos + 1), FGColor%, BGColor%, -1) 'blank from cursor to the end
    Mid$(X$, CursorPos) = Space$(Length - CursorPos + 1) 'clear that part of the string
    Length = CursorPos - 1 'show the length being at the cursor
    GoTo TGetKey 'get another keypress

    TRestore:
    Locate , Pos(0) - (CursorPos - 1) 'locate cursor at beginning of line,
    GoTo TInitialize '  and start all over again

    TRegularKey:
    If A$ < " " Then 'a control key
        On InStr(Chr$(8) + Chr$(9) + Chr$(13) + Chr$(27), A$) GOTO TBackspace, TTabKey, TEnter, TEscape
        GoTo TGetKey 'none of the above
    End If

    If CapsOn% Then 'convert to upper case if requested
        If A$ >= "a" And A$ <= "z" Then A$ = Chr$(Asc(A$) And 95)
    End If

    If NumOnly% Then 'disallow non-numeric if requested
        If A$ < "0" Or A$ > "9" Then
            Play "L16O3EC"
            GoTo TGetKey
        End If
    End If

    Call QPrint(A$, FGColor%, BGColor%, -1) 'print character
    Locate , Pos(0) + 1
    CursorPos = CursorPos + 1 'show cursor being ahead

    If Insrt GoTo THandleInsert

    Mid$(X$, CursorPos - 1, 1) = A$ 'assign the character

    'cursor is past end, increase length
    If CursorPos > Length + 1 Then Length = CursorPos - 1

    'field complete, handle as Enter key
    If Length = Max% And CursorPos > Length GoTo TEnter

    GoTo TGetKey

    THandleInsert:
    Length = Length + 1 'show string being 1 character longer
    Temp$ = Mid$(X$, CursorPos - 1) 'using Temp$ avoids a BASIC 7 bug
    Mid$(X$, CursorPos) = Temp$ 'move characters one position ahead

    Mid$(X$, CursorPos - 1, 1) = A$ 'assign the current character
    Call QPrint(Mid$(X$, CursorPos, Length - CursorPos + 1), FGColor%, BGColor%, -1) 're-print X$

    If Length = Max% GoTo TEnter 'field complete, handle as Enter key
    GoTo TGetKey

    TBackspace:
    If CursorPos = 1 GoTo TGetKey 'can't back up any more, ignore
    CursorPos = CursorPos - 1 'show cursor being 1 character before
    Locate , Pos(0) - 1 'back up the cursor
    GoTo TDel 'handle as if it were the Delete key

    TTabKey: 'reserved for your Tab routine if you
    '  want to handle it differently
    TEnter:
    GoSub TInsertOff 'clear insert, restore cursor size
    X$ = Left$(X$, Length) 'retain only the current length

    T$ = X$ 'assign the string
    Locate , , 0 'turn off the cursor
    Exit Sub

    TEscape:
    ExitCode% = 2 'show that the user pressed Escape
    GoTo TEnter 'handle as if it were the Enter Key

    TInsertOff:
    'clear Insert mode and restore cursor, depending on monitor type

    Insrt = 0
    If Clr Then
        Locate , , , 6, 7
    Else
        Locate , , , 12, 13
    End If
    Return

End Sub



'-----------------------------------
' Yes / No Input Routine
'-----------------------------------
Sub YesNoB (YN$, ExitCode, FGColor%, BGColor%)
    '********** YESNOB.BAS - BASIC yes/no input subprogram

    'Copyright (c) 1987 Ethan Winer


    '----- entry parameters
    '
    'YN$ = string to be input or edited (use the name of your choice)
    '
    '----- exit parameters
    '
    'YN$  = final edited amount
    'ExitCode indicates how editing was terminated -
    '   0 = Enter, Tab, Down-Arrow, Right-Arrow past end, or field filled
    '   1 = Shift-Tab, Up-Arrow, or Left-Arrow past beginning
    '   2 = Escape key pressed
    '
    '----- local variables
    '
    'X$ is a string version of the number while it is being input or edited
    '

    ExitCode = 0 'initialize flag

    X$ = YN$
    If X$ = "" Then X$ = " "
    Color FGColor%, BGColor%: Print X$;
    Locate , Pos(0) - 1, 1


    YGetKey:
    Call CapNum 'print Cap/Num if active
    X$ = InKey$
    If X$ = "" GoTo YGetKey

    If UCase$(X$) = "Y" Or UCase$(X$) = "N" GoTo YDone

    If X$ = Chr$(9) Or X$ = Chr$(13) GoTo YD2 'Tab or Enter

    If X$ = Chr$(27) Then 'Escape
        ExitCode = 2
        GoTo YD2
    End If


    If Len(X$) = 2 Then 'extended key
        X$ = Right$(X$, 1)
        If X$ = "P" Or X$ = "M" Then GoTo YD2 'Down arrow, Right arrow
        If X$ = "H" Or X$ = "K" Or X$ = Chr$(15) Then
            ExitCode = 1 'Up, Left, Shift-Tab
            GoTo YD2
        End If
    End If

    GoTo YGetKey


    YDone:
    If X$ > "Y" Then X$ = Chr$(Asc(X$) - 32) 'capitalize if necessary
    YN$ = X$
    Color FGColor%, BGColor%: Print YN$

    YD2:
    Locate , , 0

End Sub
